#!/bin/bash
set -e -u -o pipefail

get_images() {
  kubectl get pods -n "$1" -o jsonpath="{..image}" | tr -s '[[:space:]]' '\n' | sort | uniq
}

## Platform environment: test or live
#
platform_environment=$PLATFORM_ENV

## Deployment environment: dev (draft), production (published)
#
deployment_environment=${DEPLOYMENT_ENV-}

if [ -z "$deployment_environment" ]; then
  environment_full_name="${platform_environment}"
else
  environment_full_name="${platform_environment}-${deployment_environment}"
fi

## Concatenate K8S_TOKEN_TEST_DEV for example
##
k8s_environment_name=$(echo ${environment_full_name} | tr '-' '_' | tr [a-z] [A-Z]})
k8s_token_env_var_name="K8S_TOKEN_${k8s_environment_name}"
k8s_token=$(eval "echo \${$k8s_token_env_var_name}" | base64 -d)

build_SHA=$BUILD_SHA
k8s_cluster_cert=$K8S_CLUSTER_CERT
k8s_cluster_name=$K8S_CLUSTER_NAME
service_account=$SERVICE_ACCOUNT
application_name=$APPLICATION_NAME
namespace=$K8S_NAMESPACE

ssh_file_for_secrets=$SSH_FILE_FOR_SECRETS
encoded_git_crypt_key=$ENCODED_GIT_CRYPT_KEY

credential_name="${service_account}_$(echo ${environment_full_name} | tr '-' '_')"

################################################################
## Begin setting kubernetes context
################################################################

echo -n ${k8s_cluster_cert} | base64 -d > ./ca.crt
kubectl config set-cluster ${k8s_cluster_name} --certificate-authority=./ca.crt --server=https://api.${k8s_cluster_name}

echo "kubectl configure credentials"
kubectl config set-credentials "${credential_name}" --token="${k8s_token}"

echo "kubectl configure context"
kubectl config set-context "${credential_name}" --cluster="${k8s_cluster_name}" --user="${credential_name}" --namespace="${namespace}"

echo "kubectl use circleci context"
kubectl config use-context $credential_name

echo "apply kubernetes changes to ${platform_environment} ${deployment_environment}"

helm_command=''
chartname="${application_name}-chart"
config_file="/tmp/${application_name}-${environment_full_name}.yaml"

################################################################
## Begin git crypt
################################################################

if [[ ! -d app-secrets ]]; then
  GIT_SSH_COMMAND="ssh -v -i ${ssh_file_for_secrets} -o \"IdentitiesOnly=yes\"" git clone git@github.com:ministryofjustice/${application_name}-deploy.git app-secrets
  echo ${encoded_git_crypt_key} | base64 -d > app-secrets/git_crypt.key
  cd app-secrets && git-crypt unlock git_crypt.key && cd ..
  pwd
fi

values_config="app-secrets/values/${environment_full_name}-values.yaml"
if [[ -f "$values_config" ]]; then
  helm_command="${helm_command} -f $values_config"
else
  echo "${values_config} not found. Skipping"
fi

shared_config="app-secrets/secrets/shared-secrets-values.yaml"
if [[ -f "$shared_config" ]]; then
  helm_command="${helm_command} -f $shared_config"
else
  echo "${shared_config} not found. Skipping"
fi

secrets_config="app-secrets/secrets/${environment_full_name}-secrets-values.yaml"
if [[ -f "$secrets_config" ]]; then
  helm_command="${helm_command} -f $secrets_config"
else
  echo "${secrets_config} not found. Skipping"
fi

helm_command="helm template deploy/${chartname} $helm_command --set circleSha1=${build_SHA} --set environmentName=${environment_full_name} --set platformEnv=${platform_environment}"

echo $helm_command

################################################################
# Begin applying configuration
################################################################

echo "Writing ${environment_full_name} config to $config_file"
$helm_command > $config_file

current_images=$(get_images "${namespace}")

echo "Applying configuration"
kubectl apply -f $config_file -n "${namespace}"

################################################################
# Begin rollout and restart
################################################################

for current_image in ${current_images}; do
  if [[ $current_image == *$application_name* ]]; then
    image_deployed=false
    pod_prefix=$(echo ${current_image} | awk -F'formbuilder/' '{print $NF}' | cut -f1 -d":")
    pod_name=${pod_prefix}-${environment_full_name}
    current_SHA=${current_image##*:}

    # If the current SHA and the build SHA are the same then it is a redeployment
    # of the last commit and kubectl apply will not restart the pods.
    # In this instance we need to call rollout restart
    if [[ $current_SHA = $build_SHA ]]; then
      echo "Current SHA and the build SHA are the same"
      echo "Rolling out and restarting pods for ${pod_name}"
      kubectl -n ${namespace} rollout restart deployment ${pod_name}
    fi

    kubectl -n ${namespace} rollout status deployment ${pod_name}

    echo "Checking correct image was deployed with sha: ${build_SHA}"
    new_images=$(get_images "${namespace}")

    for image in ${new_images}; do
      if [[ $image == *$build_SHA* ]]; then
        echo "Successfully rolled out and restarted ${pod_name} pods in ${namespace}"
        image_deployed=true
      fi
    done

    if [[ "${image_deployed}" = false ]]; then
      echo "Unable to find image using ${build_SHA}"
      exit 1
    fi
  fi
done

echo "Rollout and restart completed"
